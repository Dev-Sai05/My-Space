#!/usr/bin/perl -w
#
# RCS information:
#   @(#)  Filename: badgotos.pl
#   @(#)   $Source: /home/scripts/RCS/badgotos.pl,v $
#   @(#) $Revision: 1.15 $
#   @(#)     $Name:  $		# Version label
#   @(#)     $Date: 2009-07-16 10:05:27+05:30 $
#   @(#)   $Author: gurnaraj $
#
# Name : 
#      badgotos.pl
#
# Purpose:
#      This program analyses COBOL source code to find bad GO TO statements
#      and bad PERFORM THRU statements.  Bad statements are those that are
#      potential causes for logical errors.
#
# Description:
#      This program analyses COBOL source code to find bad GO TO statements
#      and bad PERFORM THRU statements.  Bad statements are those that are
#      potential causes for logical errors.
#
#      This program is developed by Rajesh Gurnani initially for TCS BaNCS
#      Core Banking application.
#
#      TBD Detailed description of this program is yet to be filled.
#
# How to run:
#      See below - value of @MM
#
# Author:
#      Rajesh Gurnani
#
# Change History:
#     08-Sep-2008 Mon   Rajesh Gurnani
#                       Initial Idea
#     11-Sep-2008 Thu   Rajesh Gurnani
#        To             First version.  Incremental addition of features and testing.
#     25-Sep-2008 Thu   Checked into RCS. 
#     30-Oct-2008 Thu   Rajesh Gurnani
#                       Graceful handling of case when GO TO label is in next line
#     28-Nov-2008 Fri   'progdir' no longer a command line option'.
#                       Program accepts a proglist as input.
#                       

# $Log: badgotos.pl,v $
# Revision 1.15  2009-07-16 10:05:27+05:30  gurnaraj
# Savepoint
#
# Revision 1.14  2009/02/19 06:02:46  gurnaraj
# *** empty log message ***
#
# Revision 1.13  2008/12/01 00:58:10  gurnaraj
# Command line changed
#
# Revision 1.12  2008/10/30 09:43:50  gurnaraj
# Handling of GO TO alone on a line. Earlier gave error message.
#
# Revision 1.11  2008/09/25 06:21:43  gurnaraj
# Added -ef option to specify exceptions file.
# Fixed error - added DEBUGFILE to all print statements under if $debug
#
# Revision 1.10  2008/09/18 07:13:57  gurnaraj
# Fixed error in debug=0
#
# Revision 1.9  2008/09/18 06:50:52  gurnaraj
# Changed default debug=0.
#
# Revision 1.8  2008/09/18 06:48:01  gurnaraj
# Corrections by Easwar
#
# Revision 1.7  2008/09/17 06:02:40  gurnaraj
# Replaced EvaP calls by equivalent processing in basic Perl.
# Using /usr/bin/perl instead of /usr/local/bin/perl
#
# Revision 1.6  2008/09/17 04:13:25  gurnaraj
# Handled EXIT PROGRAM followed by EXIT statement in same para. Keep para type as EXIT PROGRAM
#
# Revision 1.5  2008/09/16 05:45:01  gurnaraj
# Corrected file header
#
# Revision 1.4  2008/09/16 05:42:06  gurnaraj
# Fixed recognition of GO BACK.
#
# Revision 1.3  2008/09/16 05:35:21  gurnaraj
# Bug fixes
#
# Revision 1.2  2008/09/16 05:31:16  gurnaraj
# More features added.
#
# Revision 1.1  2008/09/16 05:22:17  gurnaraj
# Initial revision
#

use strict ;
use Data::Dumper ;
use Env qw(LOGNAME) ;           # To read environment variables


    # Variables, in alphabetical order
my @cobolKeywords ;		# List of cobol keywords.  Used to know that a word is not a keyword
my $debug ;			# Debug level.  Value =0, 1, 2.
my @exceptionsList ;		# Exceptions list, read from file
my @gotos ;			# List of references to structures containing goto details
my @MM  ;                       # Messages Module - for help messages to user.
my @paraDetails ;		# List of references to structures containing paragraph details
my @PDT  ;                      # Parameter Descriptor Table for command line 
                                # arguments
my @performs ;			# List of references to structures containing perform-thru details
my $programsChecked ;           # Number of programs checked
my $programsFoundBad ;          # Number of programs in which problem found
my $errorCount ;		# Count of errors in a program
my $errorCountTotal ; 		# Count of errors across programs
my $programName ;                  # Name of the program being analysed
my @progList ;                  # List of program names to be analysed
my $reportStarted ;		# Flag - whether report file has been started for a particular file
my $verbose ;			# Flag - whether extra information should be produced on standard output
my $baseDir ;

    # Constants
sub TRUE {1} ;                  # Just like defines in C.
sub FALSE {0} ;
    # Constants for paragraph type
sub NORMAL              {0} ;
sub HAS_EXIT            {1} ;
sub HAS_EXITPROG        {2} ;

    # Subroutines.  The order is main, initialise, and then other subroutines
    # in alphabetical order.  The list and order here should exactly match
    # with that in the actual code.
sub main() ;
sub initialise() ;
sub analyse() ;
sub analyseGoto() ;
sub analysePerformThru() ;
sub isJumpAllowed($$$) ;
sub readSource() ;
sub report($$$$$$$$$$$$) ;
sub reportBadGoto($$$) ;
sub reportBadPerformThru($$$) ;
sub saveGoto($$$) ;
sub savePerformThru($$$$) ;
sub windup() ;

    # The following two initializations are kept here, as they explain the
    # input parameters to the program.  Their syntax is found in evap module.
@PDT = split /\n/, <<end_of_PDT;
PDT badgoto
  prog, p:              string = \$required
  reportfile, rf:       string 
  reportdir, rd:        string = "."
  basedir, bd:          string = "/vobs/bancs/day"
  verbose, v:           switch
  debug, d:             key 0, 1, 2, keyend = 0
  debugfile, df:        string = "debug.txt"
  expfile, ef:          string = "."
PDTEND no_file_list
end_of_PDT

@MM = split /\n/, <<end_of_MM;
badgoto
        This program checks a COBOL program source code to see if there are GO
        TO's going to a potentially wrong place, and if there are PERFORM
        THRU's with potentially wrong paragraph names.

        Usage  Examples:          badgoto
                                  perl badgoto.pl
          badgoto -prog BR0011.COB  
          badgoto -prog FNETONL.COB/BR0011.COB  
          badgoto -p FNETONL.COB/BR0011.COB -bd /vobs/bancs/day -rd /code/analysis/FNETONL.COB
          badgoto -usage_help
          badgoto -help
          badgoto -full_help

          In above examples, badgoto may need to be invoked as "perl badgoto.pl",
          and full path of badgoto.pl may be specified.

          TBD - Accept list of files to process in one invocation
          TBD - Accept name of the exceptions list.  Default is Exceptions.txt in current directory
          TBD - Define return codes to be used when invoked from check-in wrapper shell script
.prog
        Name of the COBOL program to be analysed.  If skipped, the input is
        read from standard input.
.basedir
        Base directory where the cobol source is located.
.reportfile
        Name of the output report file.  If skipped, program decides the name
        of the output file based on the name of the program being analysed.
        The output file is created in report directory.
.reportdir
        Name of the directory where the analysis output is to be written.  If
        skipped, current directory is the report directory.
.verbose
        A switch. 
        When specified, the program shows messages as it performs its job.
.debug
        An integer with possible values 0, 1, or 2.
        Value 0 means no debugging messages are produced.
        Value 1 means some debugging messages are produced.
        Value 2 means more debugging messages are produced.
.debugfile
        Name of file where the debugging messages should be written.  If
        skipped, it is "debug.txt"
.expfile
        File which specifies the programs and the gotos that are to be
        overlooked
end_of_MM



#--------------------------------------------------------------------

# The main function.  This starts the job.  Call to main is at the end of this
# file.  Unlike C programs, "main" invokation is not automatic.  The name
# "main" is not enforced by Perl.
#
sub main() 
{
    my $progfile ;

        # Open the files used in the program
    initialise();

       # Do the main job
    for my $prog ( @progList ) {
        if ( $prog =~ /^\// ) {
	    $programName = $prog ;
	} else {
	    $programName = "$baseDir/$prog" ;
	}
	$reportStarted = FALSE ;
	$errorCount = 0 ;		# Reset count of errors in a program
	$programsChecked++ ;           	# Number of programs checked
	print DEBUGFILE "Analysing program $programName\n" if $debug ;

	open PROGFILE, "<$programName" or die "Program badgoto can't open COBOL source code file $programName";

	readSource() ;      		# Read the source code to gather statements
	analyse() ;         		# Analyse the collected information
#	if ( $verbose ) {
	    print "$errorCount\terrors in\t$programName\n" ;
	    $programsFoundBad++ if ( $errorCount ) ;
#	}
	$errorCountTotal += $errorCount ; # Accumulate total error count
    }

    if ( $verbose ) {
	print "$programsChecked\tPrograms checked\n" ;
	print "$programsFoundBad\tPrograms found with problems\n" ;
	print "$errorCountTotal\tTotal errors\n" ;
    }

       # Close the opened files
    windup() ;
    return $errorCount ;
}


#--------------------------------------------------------------------

# Initialise the variable and open the Files
# Process command line arguments. 
#
sub initialise()
{
    my %cmdarg   ;                  # Values of command line arguments
    my $exceptionsFile ;
    my $debugfile ;                 # Name of the debug output file
    my $prog ;                      # Name of the program to be analysed
    my $progfile ;
    my $reportfile ;
    my $reportdir ;
    my $tmpdir ;
    my $progListFile ;

    @cobolKeywords = qw( 
        ACCEPT ACCESS ADD ADDRESS ADVANCING AFTER ALPHABET ALPHABETIC
        ALPHABETIC-LOWER ALPHABETIC-UPPER ALPHANUMERIC ALPHANUMERIC-EDITED ALS
        ALTERNATE AND ANY ARE AREA AREAS ASCENDING ASSIGN AT AUTHOR BEFORE BINARY
        BLANK BLOCK BOTTOM BY CANCEL CBLL CD CF CH CHARACTER CHARACTERS CLASS
        CLOCK-UNITS CLOSE COBOL CODE CODE-SET COLLATING COLUMN COMMA COMMON
        COMMUNICATIONS COMPUTATIONAL COMPUTE CONTENT CONTINUE
        CONTROL CONVERTING CORR CORRESPONDING COUNT CURRENCY DATE DATE-COMPILED
        DATE-WRITTEN DAY DAY-OF-WEEK DE DEBUG-CONTENTS DEBUG-ITEM DEBUG-LINE
        DEBUG-NAME DEBUG-SUB-1 DEBUG-SUB-2 DEBUG-SUB-3 DEBUGGING DECIMAL-POINT
        DELARATIVES DELETE DELIMITED DELIMITER DEPENDING DESCENDING DESTINATION
        DETAIL DISABLE DISPLAY DIVIDE DIVISION DOWN DUPLICATES DYNAMIC EGI ELSE EMI
        ENABLE END-ADD END-COMPUTE END-DELETE END-DIVIDE END-EVALUATE END-IF
        END-MULTIPLY END-OF-PAGE END-READ END-RECEIVE END-RETURN
        END-REWRITE END-SEARCH END-START END-STRING END-SUBTRACT END-UNSTRING
        END-WRITE EQUAL ERROR ESI EVALUATE EVERY EXCEPTION EXIT
        EXTEND EXTERNAL FALSE FD FILLER FINAL FIRST FOOTING FOR FROM
        GENERATE GIVING GLOBAL GO GREATER GROUP HEADING HIGH-VALUE HIGH-VALUES I-O
        IN INDEX INDEXED INDICATE INITIAL INITIALIZE
        INITIATE INPUT INSPECT INSTALLATION INTO IS JUST
        JUSTIFIED KEY LABEL LAST LEADING LEFT LENGTH LOCK MEMORY
        MERGE MESSAGE MODE MODULES MOVE MULTIPLE MULTIPLY NATIVE NEGATIVE NEXT NO NOT
        NUMBER NUMERIC NUMERIC-EDITED OCCURS OFF OMITTED ON OPEN
        OPTIONAL OR ORDER ORGANIZATION OTHER OUTPUT OVERFLOW PACKED-DECIMAL PADDING
        PAGE PAGE-COUNTER PERFORM PF PH PIC PICTURE PLUS POINTER POSITION POSITIVE
        PRINTING PROCEDURES PROCEDD PROGRAM PURGE QUEUE QUOTES
        RANDOM RD READ RECEIVE RECORD RECORDS REDEFINES REEL REFERENCE REFERENCES
        RELATIVE RELEASE REMAINDER REMOVAL REPLACE REPLACING REPORT REPORTING
        REPORTS RERUN RESERVE RESET RETURN RETURNING REVERSED REWIND REWRITE RF RH
        RIGHT ROUNDED RUN SAME SD SEARCH SECTION SECURITY SEGMENT SEGMENT-LIMITED
        SELECT SEND SENTENCE SEPARATE SEQUENCE SEQUENTIAL SET SIGN SIZE SORT
        SORT-MERGE SOURCE STANDARD
        STANDARD-1 STANDARD-2 START STATUS STOP STRING SUB-QUEUE-1 SUB-QUEUE-2
        SUB-QUEUE-3 SUBTRACT SUM SUPPRESS SYMBOLIC SYNC SYNCHRONIZED TABLE TALLYING
        TAPE TERMINAL TERMINATE TEST TEXT THAN THEN THROUGH THRU TIME TIMES TO TOP
        TRAILING TRUE TYPE UNIT UNSTRING UNTIL UP UPON USAGE USE USING VALUE VALUES
        VARYING WHEN WITH WORDS WRITE
        CONTAINS
        IF INVALID END EOP
        ALL CALL
	GOBACK
        ) ;

    # Removing call to EvaP
    # &EvaP( \@PDT, \@MM, \%cmdarg );    # evaluate command line parameters 

    # Trying to mimic evap
    my @cmdLineArgs = qw ( prog basedir reportfile reportdir verbose debug debugfile expfile proglist ) ;
    my @shortCmdLineArgs = qw ( p pd rf rd v d df ef pl ) ;
    my %keyMap = (
        'p' => 'prog' ,
        'pd' => 'basedir' ,
	'pl' => 'proglist' ,
        'rf' => 'reportfile' ,
        'rd' => 'reportdir' ,
        'ef' => 'expfile' ,
        'v' => 'verbose' ,
        'd' => 'debug' ,
        'df' => 'debugfile' 
    ) ;

    if ( $#ARGV < 0 ) {
        print "No arguments specified.\n\n" ;

        foreach (@PDT) {
            print $_."\n" ;
        }

        exit ;
    }
    my ($in_key, $key, $value) ;
    while ( $#ARGV >= 0 ) {
        $in_key = shift @ARGV ;

        $in_key =~ s/^-// ;
        if ( ! grep /^$in_key$/, @cmdLineArgs ) {
            if ( ! grep /^$in_key$/, @shortCmdLineArgs ) {
                print "Unrecognized command line argument \'$in_key\'\n" ;
                exit ;
            } else {
                $key = $keyMap{$in_key} ;
            }
        } else {
            $key = $in_key ;
        }
        if ( $key eq "verbose" ) {
            $verbose = 1 ;
        } else {
            $value = shift @ARGV ;
        }

        eval '$cmdarg{'.$key.'} = '.'$value;' ;
    }

    if ( (! defined $cmdarg{'prog'}) && (! defined $cmdarg{'proglist'}) ) {
        print "Required parameter (prog/proglist) not specified.\n" ;
        exit ;
    }
    if ( ! defined $cmdarg{'debug'} ) {
        $cmdarg{'debug'} = 0 ;
    }
    if ( ! defined $cmdarg{'debugfile'} ) {
        $cmdarg{'debugfile'} = "debug.txt" ;
    }
    if ( ! defined $cmdarg{'reportdir'} ) {
        $cmdarg{'reportdir'} = "." ;
    }
    if ( ! defined $cmdarg{'expfile'} ) {
        $cmdarg{'expfile'} = "." ;
    }
    if ( ! defined $cmdarg{'verbose'} ) {
        $cmdarg{'verbose'} = 0 ;
    }
    if ( ! defined $cmdarg{'basedir'} ) {
        $cmdarg{'basedir'} = "/vobs/bancs/day" ;
    }
    # End

    $prog = $cmdarg{'prog'} ;
    $baseDir = $cmdarg{'basedir'} ;
    $progListFile = $cmdarg{'proglist'} ;
    $reportfile = $cmdarg{'reportfile'} ;
    $reportdir = $cmdarg{'reportdir'} ;
    $verbose = $cmdarg{'verbose'} ;
    $debug = $cmdarg{'debug'} ;
    $debugfile = $cmdarg{'debugfile'} ;
    $exceptionsFile = $cmdarg{'expfile'} ;
    $tmpdir = $cmdarg{'tmpdir'} ;

    if ( $debug ) {
        open DEBUGFILE, ">$debugfile" or die "Program badgoto can not open debug output file $debugfile" ;
        select DEBUGFILE ; $| = 1 ;         # Set the output to be written to file immediately, no buffering in memory
        *STDOUT = *DEBUGFILE ;		# Redirect STDOUT output to debug file
#       *STDERR = *DEBUGFILE ;		# Redirect STDERR output to debug file
    }
    select STDOUT ;                     # Normal output on STDOUT only

    print DEBUGFILE "debug = $debug\n" if $debug ;

    my $tempPath = "." ;        # "/tmp/$LOGNAME/logs" ;
    if ( ! -d "$tempPath") {
        mkpath($tempPath, 0, 0755) ;
    }

    $reportfile = "badgotos.txt" unless $reportfile ;
    $reportdir = "." unless $reportdir ;
    $reportdir .= "/" unless $reportdir =~ /$\// ;  # Suffix slash unless it already has it
    $reportfile = "$reportdir$reportfile" ;
            
    if ( ! defined $progListFile ) {
	$baseDir = "." unless defined $baseDir ;
	$progfile = "$prog" ;

	print DEBUGFILE "progfile = $progfile\n" if $debug ;

	push @progList, $prog ;		# List of programs to analyse
    } else {
        if ( ! -r $progListFile ) { print "$progListFile does not exist/not readable\n" ; exit ; }
	open ( INPROGLIST, "<$progListFile" ) or die "Unable to open $progListFile\n" ;
	while (<INPROGLIST>) {
	    chomp $_ ;
	    s/\r$// ;
	    next if /^#/ ;
	    s/#.*// ;

	    push @progList, $_ ;
	}
	close (INPROGLIST) ;
    }

            
    print DEBUGFILE "debugfile = $debugfile\n" if $debug ;
    print DEBUGFILE "reportfile = $reportfile\n" if $debug ;

    print DEBUGFILE "Initialising\n" if  $debug  ;

        # Initialise exceptions list
    open EXCPFILE, $exceptionsFile or die "Can not open $exceptionsFile" ;

    while ( <EXCPFILE> ) {
        next if /^\s*$/ ;	# Skip blank lines
        next if /^\s*#/ ;       # Skip comment lines
	push @exceptionsList, $_ ;
    }

    close EXCPFILE ;

    open REPORTFILE, ">$reportfile" or die "Program badgoto can't open report output file $reportfile";
    select REPORTFILE ; $| = 1 ;
    select STDOUT ;
    
	# Set globals for use later
    $reportStarted = FALSE ;		# Nothing reported so far
    $programsChecked = 0 ;           	# Number of programs checked
    $programsFoundBad = 0 ;          	# Number of programs in which problem found
    $errorCount = 0 ;			# Count of errors in a program
    $errorCountTotal = 0 ; 		# Count of errors across programs

    print DEBUGFILE "At the end of init\n" if $debug ;
}


#--------------------------------------------------------------------

# Analyse the collected information to check if there are any potential problems.
#
sub analyse() 
{
    if ( $debug ) {
        print DEBUGFILE "Printing list of Exit Paras\n" ;
        for my $p (@paraDetails) {
            printf DEBUGFILE "Line %d, Para %s, ExitType %d\n", $p->{LINE}, 
                  $p->{NAME}, $p->{EXITPARA} if $p->{EXITPARA} ;
        }

        print DEBUGFILE "Printing list of All Paras\n" ;
        for my $p (@paraDetails) {
            printf DEBUGFILE "Line %d, Para %s, Index %d\n", $p->{LINE}, 
                  $p->{NAME}, $p->{INDEX} ;
        }

        print DEBUGFILE "Printing list of collected GOTOs\n" ;
        for my $g (@gotos) {
            printf DEBUGFILE "Line %d, Para %s, Goto %s\n", $g->{FROMLINE}, 
                  $g->{CALLEDFROM}{NAME}, $g->{GOTO_PARA} ;
        }

        print DEBUGFILE "Printing list of collected PERFORM-THRUs\n" ;
        for my $p (@performs) {
            printf DEBUGFILE "Line %d, Para %s, Perform %s Thru %s\n", $p->{FROMLINE}, 
                  $p->{CALLEDFROM}{NAME}, $p->{PERFORM_PARA}, $p->{THRU_PARA} ;
        }
    }

    analyseGoto() ;
    analysePerformThru() ;
}


#--------------------------------------------------------------------

# Analyse the collected information to check if there are bad GO TOs
#
sub analyseGoto() 
{
        # Analyse the GO TO's
    for my $g (@gotos) {
        my $callingParaRef = $g->{CALLEDFROM} ;
        my $gotoParaName = $g->{GOTO_PARA} ;

        printf DEBUGFILE "Analysing goto from para %s at Line %d, Goto %s\n", $callingParaRef->{NAME}, 
               $g->{FROMLINE}, $gotoParaName if $debug ;

	    # Index from where going
	my $callingParaIndex = $callingParaRef->{INDEX} ;		
	    # Index where going to. Find one nearby if there are many para by same name
        my $gotoParaIndex = getParaIndex($g->{GOTO_PARA}, $callingParaIndex) ; 

	    # Check if GO TO seems ok
        my ($ok, $fromParaIndex, $tillParaIndex) = isJumpAllowed( "goto", $callingParaIndex, $gotoParaIndex ) ;

	    # Not ok.  Report problem
        if ( ! $ok ) {
            print DEBUGFILE "Problem in line $g->{FROMLINE} in $callingParaRef->{NAME}: GO TO $g->{GOTO_PARA}\n" if $debug ;
            print DEBUGFILE "    It must not jump to para before $paraDetails[$fromParaIndex]->{NAME} (at line $paraDetails[$fromParaIndex]->{LINE})" if $debug ;
            print DEBUGFILE " and beyond $paraDetails[$tillParaIndex]->{NAME} (at line $paraDetails[$tillParaIndex]->{LINE})\n" if $debug ;

	    report( $programName, $g->{FROMLINE}, "Problem", $callingParaRef->{NAME}, 
		    "GO TO", $g->{GOTO_PARA}, "", "",
	            $paraDetails[$fromParaIndex]->{NAME}, $paraDetails[$fromParaIndex]->{LINE},
                    $paraDetails[$tillParaIndex]->{NAME}, $paraDetails[$tillParaIndex]->{LINE} ) ;
        }
    }
}


#--------------------------------------------------------------------

# Analyse the collected information to check if there are bad Perform-Thru's
#
sub analysePerformThru() 
{
        # Analyse the PERFORM THRU's
    for my $p (@performs) {
	my $skip = FALSE ;

        my $callingParaRef = $p->{CALLEDFROM} ;
        my $performParaName = $p->{PERFORM_PARA} ;
        my $thruParaName = $p->{THRU_PARA} ;
	
        printf DEBUGFILE "Analysing Perform-Thru from para %s at Line %d, Perform %s Thru %s\n", 
               $callingParaRef->{NAME}, $p->{FROMLINE}, $performParaName, $thruParaName if $debug ;

	    # Get the index of PERFORM para.  There should be only one in the file.
	my $performParaIndex = getParaIndex($p->{PERFORM_PARA}) ;
	if ( $performParaIndex < 0 ) {
	    print "Para $performParaName not found. Skipping check on PERFORM $performParaName THRU $thruParaName\n" if $verbose ;
	    $skip = TRUE ;
	}

	unless ( $skip ) {
		# Find THRU para below it
	    my $thruParaIndex = getParaIndex($p->{THRU_PARA}, $performParaIndex ) ;

	    if ( $thruParaIndex < 0 ) {
		# Could not find the THRU para below PERFORM para.  May be it is above.
		# If so, that is a problem, report it formally.  But first confirm it.
		$thruParaIndex = getParaIndex($p->{THRU_PARA}) ;	# Find any THRU para
	    }

	    if ( $thruParaIndex < 0 ) {
		print "Para $thruParaName not found. Skipping check on PERFORM $performParaName THRU $thruParaName\n" if $verbose ;
		$skip = TRUE ;
	    }
	    
	    unless ( $skip ) {
		    # Check on Perform A thru B is same as check on GO TO B from paragraph A
		my ($ok, $fromParaIndex, $tillParaIndex) = isJumpAllowed( "performThru", $performParaIndex, $thruParaIndex ) ;
		if ( ! $ok ) {
			# The THRU para is outside the expected range
		    print DEBUGFILE "Bad Perform-Thru found in line $p->{FROMLINE} in $p->{CALLEDFROM}: Perform $p->{PERFORM_PARA} Thru $p->{THRU_PARA}\n" if $debug ;
		    print DEBUGFILE "    Thru para must not be before $paraDetails[$fromParaIndex]->{NAME} and beyond $paraDetails[$fromParaIndex]->{LINE}\n" if $debug ;

		    report( $programName, $p->{FROMLINE}, "Problem", $callingParaRef->{NAME}, 
			    "PERFORM", $p->{PERFORM_PARA}, "THRU", $p->{THRU_PARA},
			    $paraDetails[$fromParaIndex]->{NAME}, $paraDetails[$fromParaIndex]->{LINE},
			    $paraDetails[$tillParaIndex]->{NAME}, $paraDetails[$tillParaIndex]->{LINE} ) ;
		}
	    } 
	}
    }
}


#--------------------------------------------------------------------

# Find the index of the para in @paraDetails, given the paragraph name
# First argument is the name of the para whose index is required.
# Second (optional) argument is the index of the para after which the named para should appear in the source code.
# This is used to pick the right para when there are many occurrences of the same para name in a cobol program.
# For an example, see program BCGPGI.COB in online programs which has multiple occurrences of SECTION-EXIT para.
#
sub getParaIndex($;$)
{
    my $paraNameToFind = $_[0] ;		# Name of the paragraph to find
    my $paraIndexAbove = $_[1] ;		# Index found should preferably be more than this
                                                # but as close as possible - For GO TOs where para name
						# is not unique

    my $paraIndex = -1 ;
    print DEBUGFILE "getParaIndex: To find index for $paraNameToFind " if $debug ;
    print DEBUGFILE "that is above $paraIndexAbove" if $debug && defined $paraIndexAbove ;
    print DEBUGFILE "\n" if $debug ;

    $paraIndexAbove = -1 unless defined $paraIndexAbove ;
    print DEBUGFILE "getParaIndex: Set paraIndexAbove to $paraIndexAbove\n" if $debug ;

    my $i ;			# Used in both For loops
    for ( $i = scalar @paraDetails - 1 ; $i >= 0 && $i > $paraIndexAbove ; $i-- ) {
	$paraIndex = $i if ( $paraDetails[$i]{NAME} eq $paraNameToFind ) ;
	# Still continue.  You may find another para by same name.  Get as close as
	# possible to $paraIndexAbove
    }

    if ( $paraIndex == -1 ) {	# Not found?  OK, go on, search remaining part of code
	for (  ; $i >= 0 ; $i-- ) {		# Continue from where left 
	    if ( $paraDetails[$i]{NAME} eq $paraNameToFind ) {
		$paraIndex = $i ;
		last ;			# Come out on first match
	    }
	}
    }

	# It is possible that some of the procedures are defined in copybooks and won't be found in COB code
    print DEBUGFILE "Can not find index for the para $paraNameToFind\n" if $paraIndex < 0 && $debug ;

    return $paraIndex ;
}


#--------------------------------------------------------------------

# Check if a particular GO TO / THRU is allowed
#
sub isJumpAllowed($$$)
{
    my $lineType      = $_[0] ;		# "goto" or "performThru"
    my $thisParaIndex = $_[1] ;		# Index of the para from where calling
    my $gotoParaIndex = $_[2] ;		# Index of the para to go to

    my $fromParaIndex ;		
    my $tillParaIndex ;		

    print DEBUGFILE "Checking if jump is allowed from $thisParaIndex to $gotoParaIndex\n" if $debug ;
    my $allowed = TRUE ;

    if ( $paraDetails[$gotoParaIndex]{EXITPARA} == HAS_EXITPROG ) {     # Jumping to para containing EXIT PROGRAM
        ;                                                   # No problem
    } else {
	if ( $lineType eq "performThru" ) {
	    $fromParaIndex = $thisParaIndex + 1 ;
	} else {	# lineType eq "goto"
		# Search for the paragraphs above, up to which it can go to
	    $fromParaIndex = $thisParaIndex ;
	    for ( my $i = $thisParaIndex ; $i >= 0 ; $i-- ) {
		if ( $paraDetails[$i]{EXITPARA} ) {
		    $fromParaIndex = $i + 1 ;       # This is an EXIT para. Can't jump to this
		    last ;
		} else {
		    $fromParaIndex = $i ;           # Can GO TO this para
		}
	    }
	}

            # Search for the paragraphs below, up to which it can go to
        my $foundExitPara = FALSE ;
        $tillParaIndex = $thisParaIndex ;
        for ( my $i = $thisParaIndex ; $i < scalar @paraDetails ; $i++ ) {
            if ( $paraDetails[$i]{EXITPARA} ) {
                $tillParaIndex = $i ;           # Can GO TO this para
                $foundExitPara = TRUE ;         # Do not come out on first Exit para, there may be more adjacent
            } elsif ( $foundExitPara ) {
                $tillParaIndex = $i - 1 ;       # This is normal para after an EXIT para. Can't jump to this
                last ;
            } else {
                $tillParaIndex = $i ;           # Can GO TO this para
                ;               # Have not yet reached Exit para, continue
            }
        }

        if ( $gotoParaIndex < $fromParaIndex || $gotoParaIndex > $tillParaIndex ) {
            $allowed = FALSE ;
        }
    }

    print DEBUGFILE "Not allowed\n" if $debug && ! $allowed ;

    return ( $allowed, $fromParaIndex, $tillParaIndex ) ;
}


#--------------------------------------------------------------------

# Open files required for processing one program
# TBD - The usage is yet to start
#
sub openFiles($)
{
    my $prog = $_[0] ;		# Name of the program to process.

    my $progfile ; # = "$baseDir$prog" ;
    if ( ! -r $progfile ) {
        die( "badgoto can not read file $progfile\n" ) ;
    }

    my $success = open PROGFILE, "<$progfile"  ;
    print STDERR "Can't open file for reading: $progfile" unless $success ;
    
    return $success ;
}

#--------------------------------------------------------------------

# Print report line, with heading if required
#
sub report($$$$$$$$$$$$)
{
    my $program		= $_[0] ; 
    my $lineNo		= $_[1] ; 
    my $finding		= $_[2] ; 
    my $para		= $_[3] ; 
    my $verb		= $_[4] ; 
    my $arg1		= $_[5] ; 
    my $arg2		= $_[6] ; 
    my $arg3		= $_[7] ; 
    my $allowedFrom	= $_[8] ; 
    my $atlineFrom	= $_[9] ; 
    my $allowedTo	= $_[10] ; 
    my $atlineTo	= $_[11] ;


        # Stripping path from program name 
    $program =~ s/.*\/// ;
    my $matchExcp = "$program\t$para\t$verb\t$arg1\t$arg2\t$arg3" ;
    unless ( grep( /$matchExcp/, @exceptionsList ) ) {
        $errorCount++ ;		# Increment error count

	    # Print heading before printing first line of the file.
	    # If nothing is to be reported, we want the file to be empty, zero bytes.
	if ( ! $reportStarted ) {
	    $reportStarted = TRUE ;
	    printf REPORTFILE "%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n", 
			      "Program", "Line No", "Status", "Para", "Verb", "Arg1", 
			      "Arg2", "Arg3", "Allowed From", "Atline", "Allowed To", "Atline" ;
	}

	printf REPORTFILE "%s\t%d\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%d\t%s\t%d\n", 
			  $program, $lineNo, $finding, $para, 
			  $verb, $arg1, $arg2, $arg3, 
			  $allowedFrom, $atlineFrom, $allowedTo, $atlineTo ;
    }
}

#--------------------------------------------------------------------

# Read the code source code to gather the PERFORM THRU and GO TO statements
#
sub readSource() 
{
    my $cobchar = "[A-Za-z_0-9-]" ;      # Valid characters in COBOL word. Match one char
    my $cobchars = "[A-Za-z_0-9-]*" ;      # Valid characters in COBOL word. Match 0-n chars
    my $cobletter = "[A-Za-z]" ;      # Valid characters for start of COBOL word
#    my $cobword = "\\b${cobletter}${cobchars}\\b" ;      # Valid character sequence in COBOL word
    my $cobword = "\\b${cobchar}${cobchars}\\b" ;      # Valid character sequence in COBOL word - It can start with a digit!

    my $hasKeyword ;
    my $lineno ;
    my $lineType ;
    my $thisParaIndex ;
    my $thisParaName ;
    my $thisParaRef ;
    my $performPara ;
    my $prevLineType ;
    my $prevLineWithDot ;
    my $procDivStarted ;
    my $savedLine ;
    my $thisLineWithDot ;
    my $thruPara ;

    $lineno = 0 ;
    $procDivStarted = FALSE ;
    $thisParaName = "" ;

	# Read the program file containing COBOL source code
    while (<PROGFILE>) {
        $lineno++ ;				# Line number in source code
        my $ignoreLine = FALSE ;
        $savedLine = $_ ;
        print DEBUGFILE "$savedLine" if $debug ;
        chomp ;
        s/^(.{72}).*/$1/ ;  			# Delete everything beyond column 72
        $ignoreLine = TRUE if /^......\*/ ;
        $ignoreLine = TRUE if /^......\// ;
        $ignoreLine = TRUE if /^......\s*$/ ;
        $ignoreLine = TRUE unless /^......./ ;
        if ( $ignoreLine ) {
            next ;
        }

            # Set PREV values from previous line
        $prevLineType = $lineType ;
        $prevLineWithDot = $thisLineWithDot ;
        $prevLineType = "" if ( $prevLineWithDot ) ;        # Previous line will not continue

        print DEBUGFILE "Previous line had dot\n" if ( $debug && $prevLineWithDot ) ;
            # Initialise values for this line
        $lineType = "" ;
        $hasKeyword = $thisLineWithDot = FALSE ;

	print DEBUGFILE "After truncating, $_\n" if $debug ;
        s/^......\s*// ;    # Discard the initial 6 columns and leading spaces/tabs
        $_ = uc ;           # Convert the line to upper case, so that case does not trouble any more
        s/\s+/ /g ;          # Convert all tabs and multiple spaces to single space, so that 
                            # search patterns are easier to write

        if ( ! $procDivStarted && /^(PROCEDURE DIVISION\b)/ ) {   # Procedure division starts
            $procDivStarted = TRUE ;   
            $thisParaName = "PROCEDURE DIVISION" ;    # For those programs which start without a para name
            print DEBUGFILE "Procedure Division started at line $lineno\n" if $debug ;
	    $thisParaRef = {} ;
	    my $count = push @paraDetails, $thisParaRef ;
	    $thisParaIndex = $count - 1 ;      		# Index is zero based
	    $thisParaRef->{LINE} = $lineno ;		# Line number in source code
	    $thisParaRef->{NAME} = $thisParaName ;          # Para name can be accessed from this structure as well
	    $thisParaRef->{EXITPARA} = NORMAL ;            	# Assume it is normal para, until an EXIT statement is found in it.
	    $thisParaRef->{LINETEXT} = $savedLine ;		# Complete text of the line
	    $thisParaRef->{INDEX} = $thisParaIndex ;	# Index of entry in @paraDetails, zero based index
        }

        next unless $procDivStarted ;       # No point examining lines before procedure division

        $thisLineWithDot = /\.\s*$/ ;       # Does this line end with a period
    #    print DEBUGFILE "The line ends with a dot\n" if ( $debug and $thisLineWithDot ) ;
	print DEBUGFILE "Before picking firstword, $_\n" if $debug ;
        if ( /^($cobword)/ ) {   # Pick the first word, if there is one
            my $firstword = $1 ;

            $hasKeyword = ( grep( /^$firstword$/, @cobolKeywords ) ) ; 	# First word is cobol keyword
            
            if ( $hasKeyword && $debug >= 1 ) {
    #            print DEBUGFILE "Keyword is $firstword for line $_\n" ;
                ;
            }
        }

        print DEBUGFILE "The line has keyword\n" if ( $debug and $hasKeyword ) ;
        if ( ! $hasKeyword && $prevLineWithDot ) { 
            print DEBUGFILE "Checking if this starts a para\n" if $debug ;
            # This is likely to be a para name
            if ( /^(${cobword})\s*(SECTION)?\s*\./ || /^(${cobword}\s*)\./ ) {  # ProcedureName, optional "SECTION", followed by dot
                $thisParaName = $1 ;
                print DEBUGFILE "Yes, it starts a para.  Paraname is $thisParaName\n" if $debug ;
		$thisParaRef = {} ;
                my $count = push @paraDetails, $thisParaRef ;
		$thisParaIndex = $count - 1 ;      		# Index is zero based
                $thisParaRef->{LINE} = $lineno ;		# Line number in source code
                $thisParaRef->{NAME} = $thisParaName ;          # Para name can be accessed from this structure as well
                $thisParaRef->{EXITPARA} = NORMAL ;            	# Assume it is normal para, until an EXIT statement is found in it.
                $thisParaRef->{LINETEXT} = $savedLine ;		# Complete text of the line
                $thisParaRef->{INDEX} = $thisParaIndex ;	# Index of entry in @paraDetails, zero based index
		
                s/^${cobword}\s*(SECTION)?\s*\.\s+// ;  # Remove procedure name.  Sometime EXIT statement is on same line. Continue looking for that
            }
        }

            # In the search patterns, \b means matching a word boundary
        if ( /^AT END GO TO\b/ ) {   # It is a GO TO line.
            $lineType = "goto" ;
        } elsif ( /^GO TO\b/ ) {   # It is GO TO line
            $lineType = "goto" ;
        } elsif ( /^PERFORM .* THRU\b/ ) {   # It is PERFORM THRU line
            $lineType = "performThru" ;
        } elsif ( /^PERFORM UNTIL\b/ ) {   # It is PERFORM Until line
            $lineType = "performUntil" ;
        } elsif ( /^PERFORM\b/ ) {   # It is PERFORM line
            $lineType = "perform" ;
        } elsif ( /^THRU\b/ && $prevLineType eq "perform" ) {   # It is THRU line
            $lineType = "thru" ;
        } elsif ( /^EXIT\b/ || /^EXIT PROGRAM\b/ || /^STOP RUN\b/ || /^GOBACK\b/ ) {   # EXIT line
            $thisParaRef->{EXITPARA} = HAS_EXIT unless $thisParaRef->{EXITPARA} >= HAS_EXIT ;
	    print DEBUGFILE "It is an EXIT para\n" if $debug ;
            if ( /^EXIT PROGRAM\b/ || /^STOP RUN\b/ || /^GOBACK\b/ ) {   # EXIT line
                $thisParaRef->{EXITPARA} = HAS_EXITPROG ;
		print DEBUGFILE "It is an EXIT PROGRAM para\n" if $debug ;
            }
        }

        if ( $lineType eq "perform" ) {
            if ( $thisLineWithDot  ) {    # This must be perform section.  Not interested
                next ;
            }  # else
            if ( /^PERFORM (${cobword})/ ) {      # Pick the perform paraname and thru paraname
                $performPara = $1 ;
		print DEBUGFILE "Gathered Perform para name $performPara\n" if $debug ;
            }
        }

        print DEBUGFILE "lineType = $lineType\n" if ( $debug && $lineType ) ;
        if ( $lineType eq "performThru" ) {    # 
            if ( /^PERFORM (${cobword}) THRU (${cobword})/ ) {      # Pick the perform paraname and thru paraname
                $performPara = $1 ;
                $thruPara = $2 ;
		print DEBUGFILE "perform Para is ", $performPara, "\n" if $debug ;
		print DEBUGFILE "Thru Para is ", $thruPara, "\n" if $debug ;
                print DEBUGFILE "Saving PERFORM THRU call for line $savedLine" if $debug ;
    #            print DEBUGFILE "Paraname = $thisParaName, performPara = $performPara, ThruPara = $thruPara, line = $lineno\n" if $debug ;
                savePerformThru( $lineno, $thisParaRef, $performPara, $thruPara ) ;
                $performPara = $thruPara = "" ;
            } else {
                print DEBUGFILE "Did not find para names in PERFORM THRU call in \n$_\nfor line $savedLine" if $debug ;
            }
        }

        if ( $lineType eq "thru" ) {    # 
            /^THRU (${cobword})/ ;      # Pick the thru paraname
            $thruPara = $1 ;
            print DEBUGFILE "Saving THRU call for line $savedLine" if $debug ;
            savePerformThru( $lineno, $thisParaRef, $performPara, $thruPara ) ;
            $performPara = $thruPara = "" ;
        }

        if ( $lineType eq "goto" ) {    # 
            s/^AT END\s*// ;      # Remove the "AT END" if there
            if ( /^GO TO ${cobword} ${cobword}/ ) {      # Is it GO TO with multiple labels?
                $lineType = "gotoDepending" ;
                print DEBUGFILE "Changed linetype to gotodepending\n" if $debug ;
                s/^GO TO\s*// ;   # Remove GO TO, leave only the target proc names
                my @targetList = split / /, $_ ;            # Get list of target paragraph names
                for my $gotoPara ( @targetList ) {
                    saveGoto( $lineno, $thisParaRef, $gotoPara ) ;
                }
            } else {
                if ( /^GO TO (${cobword})/ ) {      # Pick up the target para
                    my $gotoPara = $1 ;
                    saveGoto( $lineno, $thisParaRef, $gotoPara ) ;
		    $lineType = "gotoDepending" unless ( $thisLineWithDot ) ;
                } else {
                    print DEBUGFILE "GOTO without target para in line $lineno in $programName.  Will check next line\n" if $debug ;
		    $lineType = "gotoDepending" unless ( $thisLineWithDot ) ; # Although it may be plain GO TO, the logic is common.
                }
            }
        }

        if ( ! $hasKeyword && $prevLineType eq "gotoDepending" ) {
            $lineType = "gotoDepending" ;
            s/DEPENDING\b.*// ;                     # Remove DEPENDING and following text
            my @targetList = split ;                # Get list of target paragraph names
            for my $gotoPara ( @targetList ) {
                saveGoto( $lineno, $thisParaRef, $gotoPara ) ;
            }
        }

    }
}


#--------------------------------------------------------------------

# Save the GO TO details.  These will be used later during analysis
#
sub saveGoto($$$)
{
    my $goto = {} ;
    $goto->{FROMLINE} = $_[0] ;		# The line number in source code, where GO TO is present
    $goto->{CALLEDFROM} = $_[1] ;	# The reference of the paragraph, from which it is called.  Ref give all information
    $goto->{GOTO_PARA} = $_[2] ;	# Name of the paragraph going to
    push @gotos, $goto ;
    print DEBUGFILE "Saved GO TO $_[2], called from $_[1]->{NAME} (index $_[1]->{INDEX}) at line $_[0]\n" if $debug ;
}

#--------------------------------------------------------------------

# Save the PERFORM THRU details.  These will be used later during analysis
#
sub savePerformThru($$$$)
{
    my $perform = {} ;
    $perform->{FROMLINE} = $_[0] ;	# The line number in source code, where PERFORM THRU is present
    $perform->{CALLEDFROM} = $_[1] ;	# The reference of the paragraph, from which it is called.  Ref give all information
    $perform->{PERFORM_PARA} = $_[2] ;	# Name of the paragraph to be performed
    $perform->{THRU_PARA} = $_[3] ;	# Name of the paragraph to be performed thru

        # Assumed to be normal, until an EXIT statement is found in it
    $perform->{EXITPARA} = NORMAL ;

    push @performs, $perform ;
#    print DEBUGFILE "Saved Perform $_[2] Thru $_[3], called from $_[1]->{NAME} (index $_[1]->{INDEX}) at line $_[0]\n" if $debug ;
    print DEBUGFILE "Saved Perform $_[2] " if $debug ;
    print DEBUGFILE "Thru $_[3], " if $debug ;
    print DEBUGFILE "called from $_[1]->{NAME} " if $debug ;
    print DEBUGFILE "(index $_[1]->{INDEX}) " if $debug ;
    print DEBUGFILE "at line $_[0]\n" if $debug ;
}


#------------------------------------------------------------------------- 

# Performs clean up on exit.
#

sub windup() 
{
    close PROGFILE ;
    close REPORTFILE ;
    close DEBUGFILE ;

        # Remove the debug file if it was empty
#    my $filesize = (stat($debugfile))[7] ;
#    if ( $filesize == 0 ) {
#        unlink($debugfile) ;
#    }
}


#--------------------------------------------------------------------
# This is invoked automatically when the program exits

END {
    windup() ;
}


#--------------------------------------------------------------------

# Most Important.  Execute the main function.

my $status = main();
exit $status ;

