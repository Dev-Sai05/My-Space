import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;

import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.*;
import java.io.File;
import java.io.FileNotFoundException;

public class JavaCodeAnalyzer {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(JavaCodeAnalyzer::createAndShowGUI);
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("Java Code Analyzer");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(600, 400);
        frame.setLayout(new BorderLayout());

        JTextArea resultArea = new JTextArea();
        resultArea.setEditable(false);
        JScrollPane scrollPane = new JScrollPane(resultArea);

        JButton openFileButton = new JButton("Open Java File");
        openFileButton.addActionListener(e -> {
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setFileFilter(new FileNameExtensionFilter("Java Files", "java"));
            int returnValue = fileChooser.showOpenDialog(frame);
            if (returnValue == JFileChooser.APPROVE_OPTION) {
                File selectedFile = fileChooser.getSelectedFile();
                try {
                    String analysisResult = analyzeJavaFile(selectedFile);
                    resultArea.setText(analysisResult);
                } catch (FileNotFoundException ex) {
                    resultArea.setText("Error: File not found!");
                }
            }
        });

        frame.add(openFileButton, BorderLayout.NORTH);
        frame.add(scrollPane, BorderLayout.CENTER);

        frame.setVisible(true);
    }

    private static String analyzeJavaFile(File file) throws FileNotFoundException {
        StringBuilder analysisResult = new StringBuilder();
        JavaParser parser = new JavaParser();

        CompilationUnit compilationUnit = parser.parse(file).getResult().orElseThrow(() -> new FileNotFoundException("Unable to parse file"));

        // Check for try-catch blocks
        analysisResult.append("Try-Catch Block Analysis:\n");
        new TryCatchBlockChecker().visit(compilationUnit, analysisResult);

        // Check for null assignments
        analysisResult.append("\nNull Assignment Analysis:\n");
        new NullAssignmentChecker().visit(compilationUnit, analysisResult);

        // Check for resource closures
        analysisResult.append("\nResource Closure Analysis:\n");
        new ResourceClosureChecker().visit(compilationUnit, analysisResult);

        // Check for braces and if-else statements
        analysisResult.append("\nBraces and If-Else Check:\n");
        new BracesIfElseChecker().visit(compilationUnit, analysisResult);

        // Check if no issues found
        if (analysisResult.length() == 0 || analysisResult.toString().contains("Analysis:")) {
            analysisResult.append("\nNo issues found! Code is clean.");
        }

        return analysisResult.toString();
    }

    private static class TryCatchBlockChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            BlockStmt body = md.getBody().orElse(null);
            if (body != null && body.getStatements().stream().noneMatch(s -> s.isTryStmt())) {
                result.append("  Method ").append(md.getName()).append(" does not contain a try-catch block.\n");
            }
        }
    }

    private static class NullAssignmentChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            md.getParameters().forEach(param -> {
                if (param.getType().isReferenceType() && !param.getAnnotations().isNonEmpty()) {
                    result.append("  Parameter ").append(param.getName()).append(" in method ")
                          .append(md.getName()).append(" might not be checked for null.\n");
                }
            });
        }
    }

    private static class ResourceClosureChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            md.getBody().ifPresent(body -> {
                if (body.getStatements().stream().anyMatch(s -> s.toString().contains("open"))) {
                    if (body.getStatements().stream().noneMatch(s -> s.toString().contains("close"))) {
                        result.append("  Method ").append(md.getName()).append(" might not close opened resources.\n");
                    }
                }
            });
        }
    }

    private static class BracesIfElseChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            BlockStmt body = md.getBody().orElse(null);
            if (body != null) {
                body.getStatements().forEach(stmt -> {
                    // Check for missing braces in if-else blocks
                    if (stmt.toString().contains("if") || stmt.toString().contains("else")) {
                        if (!stmt.toString().contains("{") || !stmt.toString().contains("}")) {
                            result.append("  Method ").append(md.getName()).append(" has an if/else block without braces.\n");
                        }
                    }
                });
            }
        }
    }
}



-----------

import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.CompilationUnit;
import com.github.javaparser.ast.body.MethodDeclaration;
import com.github.javaparser.ast.stmt.BlockStmt;
import com.github.javaparser.ast.stmt.Statement;
import com.github.javaparser.ast.visitor.VoidVisitorAdapter;

import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import java.awt.*;
import java.io.File;
import java.io.FileNotFoundException;

public class JavaCodeAnalyzer {
    public static void main(String[] args) {
        SwingUtilities.invokeLater(JavaCodeAnalyzer::createAndShowGUI);
    }

    private static void createAndShowGUI() {
        JFrame frame = new JFrame("Java Code Analyzer");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(600, 400);
        frame.setLayout(new BorderLayout());

        JTextArea resultArea = new JTextArea();
        resultArea.setEditable(false);
        JScrollPane scrollPane = new JScrollPane(resultArea);

        JButton openFileButton = new JButton("Open Java File");
        openFileButton.addActionListener(e -> {
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setFileFilter(new FileNameExtensionFilter("Java Files", "java"));
            int returnValue = fileChooser.showOpenDialog(frame);
            if (returnValue == JFileChooser.APPROVE_OPTION) {
                File selectedFile = fileChooser.getSelectedFile();
                try {
                    String analysisResult = analyzeJavaFile(selectedFile);
                    resultArea.setText(analysisResult);
                } catch (FileNotFoundException ex) {
                    resultArea.setText("Error: File not found!");
                }
            }
        });

        frame.add(openFileButton, BorderLayout.NORTH);
        frame.add(scrollPane, BorderLayout.CENTER);

        frame.setVisible(true);
    }

    private static String analyzeJavaFile(File file) throws FileNotFoundException {
        StringBuilder analysisResult = new StringBuilder();
        JavaParser parser = new JavaParser();

        CompilationUnit compilationUnit = parser.parse(file).getResult().orElseThrow(() -> new FileNotFoundException("Unable to parse file"));

        // Check for try-catch blocks
        analysisResult.append("Try-Catch Block Analysis:\n");
        new TryCatchBlockChecker().visit(compilationUnit, analysisResult);

        // Check for null assignments
        analysisResult.append("\nNull Assignment Analysis:\n");
        new NullAssignmentChecker().visit(compilationUnit, analysisResult);

        // Check for resource closures
        analysisResult.append("\nResource Closure Analysis:\n");
        new ResourceClosureChecker().visit(compilationUnit, analysisResult);

        // Check for braces and if-else statements
        analysisResult.append("\nBraces and If-Else Check:\n");
        new BracesIfElseChecker().visit(compilationUnit, analysisResult);

        // Check if no issues found
        if (analysisResult.length() == 0 || analysisResult.toString().contains("Analysis:")) {
            analysisResult.append("\nNo issues found! Code is clean.");
        }

        return analysisResult.toString();
    }

    private static class TryCatchBlockChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            BlockStmt body = md.getBody().orElse(null);
            if (body != null && body.getStatements().stream().noneMatch(s -> s.isTryStmt())) {
                result.append("  Method ").append(md.getName())
                        .append(" at line ").append(md.getBegin().get().line)
                        .append(" does not contain a try-catch block.\n");
            }
        }
    }

    private static class NullAssignmentChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            md.getParameters().forEach(param -> {
                if (param.getType().isReferenceType() && !param.getAnnotations().isNonEmpty()) {
                    result.append("  Parameter ").append(param.getName())
                            .append(" in method ").append(md.getName())
                            .append(" at line ").append(md.getBegin().get().line)
                            .append(" might not be checked for null.\n");
                }
            });
        }
    }

    private static class ResourceClosureChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            md.getBody().ifPresent(body -> {
                if (body.getStatements().stream().anyMatch(s -> s.toString().contains("open"))) {
                    if (body.getStatements().stream().noneMatch(s -> s.toString().contains("close"))) {
                        result.append("  Method ").append(md.getName())
                                .append(" at line ").append(md.getBegin().get().line)
                                .append(" might not close opened resources.\n");
                    }
                }
            });
        }
    }

    private static class BracesIfElseChecker extends VoidVisitorAdapter<StringBuilder> {
        @Override
        public void visit(MethodDeclaration md, StringBuilder result) {
            super.visit(md, result);
            BlockStmt body = md.getBody().orElse(null);
            if (body != null) {
                body.getStatements().forEach(stmt -> {
                    // Check for missing braces in if-else blocks
                    if (stmt.toString().contains("if") || stmt.toString().contains("else")) {
                        if (!stmt.toString().contains("{") || !stmt.toString().contains("}")) {
                            result.append("  Method ").append(md.getName())
                                    .append(" at line ").append(stmt.getBegin().get().line)
                                    .append(" has an if/else block without braces.\n");
                        }
                    }
                });
            }
        }
    }
}